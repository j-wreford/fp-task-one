<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="0f65cb7c-ce96-4e56-a495-a59f1aa4fadb" name="Default Changelist" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ProjectId" id="1ZGOQ70IZuxhkxy1Whyy7IrwRAe" />
  <component name="PropertiesComponent">
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
  </component>
  <component name="ReplState" timestamp="1585833477370">{:repl-history {:ide [], :local [{:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (zipmap (keys graph) (map (fn [neighbours]\n                                                          (select #(contains? unvisited' %) neighbours))\n                                                        (vals graph)))]\n\n          ;(println graph)\n          ;(println unvisited-graph)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3029, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (do\n                                (println unvisited')\n                                (zipmap (keys graph) (map (fn [neighbours]\n                                                          (select #(contains? unvisited' %) neighbours))\n                                                        (vals graph))))]\n\n          ;(println graph)\n          ;(println unvisited-graph)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3119, :ns &quot;solver.core&quot;} {:command &quot;(reduce-kv (fn [m k v]\n             m)\n           {} {:a #{1 2 3}})&quot;, :offset 67, :ns &quot;server.core&quot;} {:command &quot;(reduce-kv (fn [m k v]\n             (assoc m k v))\n           {} {:a #{1 2 3}})&quot;, :offset 79, :ns &quot;server.core&quot;} {:command &quot;(reduce-kv (fn [m k v]\n             (assoc m k (select v #{2})))\n           {} {:a #{1 2 3}})&quot;, :offset 93, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [m k v]\n                                           (assoc m k (select #(contains? unvisited' %) v)))\n                                         {} graph)]\n\n\n\n          ;(println graph)\n          ;(println unvisited-graph)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2979, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (println (select #(contains? unvisited' %) neighbours))\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3037, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (println g)\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2993, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println unvisited-graph)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (zipmap\n                               (keys distances)\n                               (map\n                                 ;; update the distance value for each coordinate\n                                 (fn [coord]\n                                   ;; if this coordinate is a neighbour of the current coordinate...\n                                   (if-let [neighbour (get neighbours coord)]\n                                     ;; ...update the distance value for the current coordinate\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)] ;; all passages have a weighting of 1\n                                       ;; if this coordinate doesn't have a distance, or if the new distance is\n                                       ;; more efficient than its previous value...\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         ;; ...update the distance value for this coordinate with the new one\n                                         sum\n                                         ;; else, don't change the value\n                                         distance))\n                                     ;; else, don't change the value\n                                     (get distances coord)))\n                                 (keys distances)))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2975, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance 1\n                  neighbours 1\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2996, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println distances)\n          \n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3102, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println (get distances current))\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3106, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance 1\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3039, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours 1\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3018, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (select-keys (get graph current) unvisited')\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3061, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (println \&quot;hello\&quot;)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3046, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (println current-distance)\n                               (println neighbours)\n                               (zipmap\n                                 (keys distances)\n                                 (map\n                                   ;; update the distance value for each coordinate\n                                   (fn [coord]\n                                     ;; if this coordinate is a neighbour of the current coordinate...\n                                     (if-let [neighbour (get neighbours coord)]\n                                       ;; ...update the distance value for the current coordinate\n                                       (let [distance (get distances coord)\n                                             sum (inc current-distance)] ;; all passages have a weighting of 1\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       ;; else, don't change the value\n                                       (get distances coord)))\n                                   (keys distances))))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 3107, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (reduce-kv\n                                 (fn [d coord distance]\n                                   (if-let [neighbour (get neighbours coord)]\n                                     (let [distance (get distances coord)\n                                           sum (inc current-distance)]\n                                       (if (or (nil? distance) (&lt; sum distance))\n                                         sum\n                                         distance))\n                                     (get distances coord)))\n                                 {} distances)\n\n                               )]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2152, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (reduce-kv\n                                 (fn [d coord distance]\n                                   (if-let [neighbour (get neighbours coord)]\n                                     (println neighbour)\n                                     (get distances coord)))\n                                 {} distances)\n\n                               )]\n              (recur distances' next unvisited'))))))))&quot;, :offset 1886, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (reduce-kv\n                                 (fn [d coord distance]\n                                   (if-let [neighbour (get neighbours coord)]\n                                     (println neighbour (get distances coord))\n                                     (get distances coord)))\n                                 {} distances)\n\n                              )]\n              (recur distances' next unvisited'))))))))&quot;, :offset 1907, :ns &quot;solver.core&quot;} {:command &quot;(map (fn [x] (println x)) {:a 1 :b 2 :c 3})&quot;, :offset 43, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         ;; if this coordinate doesn't have a distance, or if the new distance is\n                                         ;; more efficient than its previous value...\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           ;; ...update the distance value for this coordinate with the new one\n                                           sum\n                                           ;; else, don't change the value\n                                           distance))\n                                       distance)\n                                     (assoc kv coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2525, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (do\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (println coord)\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (assoc kv coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2192, :ns &quot;solver.core&quot;} {:command &quot;(map (fn [[k v] x] (println k v)) {:a 1 :b 2 :c 3})&quot;, :offset 51, :ns &quot;server.core&quot;} {:command &quot;(map (fn [[k v :as x]] (println k v)) {:a 1 :b 2 :c 3})&quot;, :offset 55, :ns &quot;server.core&quot;} {:command &quot;(map (fn [[k v :as x]] (println k v) x) {:a 1 :b 2 :c 3})&quot;, :offset 57, :ns &quot;server.core&quot;} {:command &quot;(map (fn [[k v :as x]] (println k v) (assoc x k v)) {:a 1 :b 2 :c 3})&quot;, :offset 69, :ns &quot;server.core&quot;} {:command &quot;(map\n  (fn [[k v :as x]]\n    (println k v)\n    {k v})\n  {:a 1 :b 2 :c 3})&quot;, :offset 73, :ns &quot;server.core&quot;} {:command &quot;(into {} (map\n  (fn [[k v :as x]]\n    (println k v)\n    {k v})\n  {:a 1 :b 2 :c 3}))&quot;, :offset 83, :ns &quot;server.core&quot;} {:command &quot;(-&gt;&gt; 1 {:foo})&quot;, :offset 14, :ns &quot;server.core&quot;} {:command &quot;(-&gt;&gt; 1 (hash-map :a))&quot;, :offset 21, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (println coord)\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2190, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [a]\n                                   (println a)\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (println coord)\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2222, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [a]\n                                   (println a)\n                                   )\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 1722, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [kv]\n                                   (let [[coord distance] kv]\n                                     (-&gt;&gt;\n                                       (if-let [neighbour (get neighbours coord)]\n                                         (println coord)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance))\n                                         distance)\n                                       (hash-map coord))))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2257, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (println coord)\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2197, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     0\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 1795, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (println current-distance)\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2210, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (\&quot;here\&quot;)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2162, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println \&quot;here\&quot;)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2170, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println current)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2171, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          (println unvisited-graph)\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2179, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2142, :ns &quot;solver.core&quot;} {:command &quot;(clojure.stacktrace/print-stack-trace *e 30)&quot;, :offset 44, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       \n                                       (println \&quot;here\&quot;)\n                                       \n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2278, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (println \&quot;here\&quot;)\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2200, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do (println \&quot;here\&quot;) (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2164, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println current-distance)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2262, :ns &quot;solver.core&quot;} {:command &quot;(inc nil)&quot;, :offset 9, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2255, :ns &quot;solver.core&quot;} {:command &quot;(+ nil 1)&quot;, :offset 9, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      (println distances)\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2282, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      (println current)\n      (println distances)\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         ;(println neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2307, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      (println current)\n      (println distances)\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (first (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println \&quot;neighbour: \&quot; neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2320, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      (println current)\n      (println distances)\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println \&quot;neighbour: \&quot; neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2319, :ns &quot;solver.core&quot;} {:command &quot;(defn maze-&gt;string\n  \&quot;Returns a string representation of a maze with the given size and passages\&quot;\n  [maze]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(string? %)]}\n  (let [size (get-in maze [:maze-config :size])\n        passages (:passages maze)]\n    (str\n      \&quot;\\n+\&quot; (apply str (repeat (:cols size) \&quot;---+\&quot;))\n      (reduce\n        (fn [a row]\n          (-&gt;&gt;\n            (reduce\n              (fn [b coord]\n                ; build upon the top string\n                [(str (first b) \&quot;   \&quot; (if (passage-exists-at? passages coord :east) \&quot; \&quot; \&quot;|\&quot;))\n                 ; build upon the bottom string\n                 (str (last b) (if (passage-exists-at? passages coord :south) \&quot;   \&quot; \&quot;---\&quot;) \&quot;*\&quot;)])\n              [\&quot;\\n|\&quot; \&quot;\\n*\&quot;]\n              row)\n            ; join the top and bottom strings\n            (apply str)\n            ; join this row string with the rest of the row strings\n            (str a)))\n        \&quot;\&quot;\n        (gen-coords size)))))&quot;, :offset 948, :ns &quot;solver.core&quot;} {:command &quot;(maze-&gt;string maze)&quot;, :offset 19, :ns &quot;solver.core&quot;} {:command &quot;(ns maze.core\n  (:require [clojure.spec.alpha :as s]\n            [maze.spec :as maze-spec]))\n\n(defn coord-valid?\n  \&quot;Returns true if the given coordinate is within the boundary dictated by size\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(boolean? %)]}\n  (let [[row col] coord]\n    (and\n      (&lt;= 0 row (dec (:rows size)))\n      (&lt;= 0 col (dec (:cols size))))))\n\n(defn neighbour-coord\n  \&quot;Returns a neighbouring coordinate at the given cardinal direction\&quot;\n  [coord direction]\n  {:pre  [(s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(s/valid? ::maze-spec/coordinate %)]}\n  (cond\n    (= direction :north) (assoc coord 0 (dec (first coord)))\n    (= direction :south) (assoc coord 0 (inc (first coord)))\n    (= direction :east)  (assoc coord 1 (inc (last coord)))\n    (= direction :west)  (assoc coord 1 (dec (last coord)))))\n\n(defn neighbour-coords\n  \&quot;Returns a map of neighbouring coordinates keyed by their cardinal direction\&quot;\n  [coord]\n  {:pre  [(s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/valid? ::maze-spec/neighbour-coordinates %)]}\n  (-&gt;&gt;\n    (map #(neighbour-coord coord %1) [:north :south :east :west])\n    (interleave [:north :south :east :west])\n    (apply hash-map)))\n\n(defn valid-neighbour-coord\n  \&quot;Returns a valid neighbour coordinate, or nil\&quot;\n  [size coord direction]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(s/valid? ::maze-spec/nilable-coordinate %)]}\n  (let [neighbour (neighbour-coord coord direction)]\n    (if (coord-valid? size neighbour)\n      neighbour)))\n\n(defn valid-neighbour-coords\n  \&quot;Returns a map of valid or nil neighbouring coordinates keyed by their cardinal direction\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/valid? ::maze-spec/neighbour-coordinates %)]}\n  (reduce-kv\n    (fn [kvs k _]\n      (assoc kvs k (valid-neighbour-coord size coord k)))\n    {} (neighbour-coords coord)))\n\n(defn safe-neighbour-coords\n  \&quot;Calls valid-neighbour-coords with nil values removed\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/or ::maze-spec/cardinal-direction ::maze-spec/coordinate)]}\n  (apply merge\n         (for [[k v] (valid-neighbour-coords size coord)\n               :when (not (nil? v))] {k v})))\n\n(defn passage-exists?\n  \&quot;Returns true when passages contains coord-pair or coord-pair reversed\&quot;\n  [passages coord-pair]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate-pair coord-pair)]\n   :post [(or (boolean? %) (nil? %))]}\n  (some\n    #(or (= %1 coord-pair) (= (reverse %1) coord-pair))\n    passages))\n\n(defn passage-exists-at?\n  \&quot;Returns true when passages contains a pairing of the given coord and a neighbour of it\&quot;\n  [passages coord direction]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(or (boolean? %) (nil? %))]}\n  (passage-exists? passages (vector coord (neighbour-coord coord direction))))\n\n(defn add-passage\n  \&quot;Adds a passage between coord-pair to the given passages vector\&quot;\n  [passages coord-pair]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate-pair coord-pair)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (if (not (passage-exists? passages coord-pair))\n    (conj passages coord-pair)\n    passages))\n\n(defn gen-coords\n  \&quot;Generates a 2d vector of coordinates that covers all points of a grid with the given size\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/coordinate-vector-2d %)]}\n  (into [] (for [row (range (:rows size))]\n    (into [] (for [col (range (:cols size))]\n      [row col])))))\n\n(defn gen-coords-seq\n  \&quot;Returns gen-cords as a sequence of coordinates\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/coordinate-seq %)]}\n  (map vec (partition 2 (flatten (gen-coords size)))))\n\n(defn gen-passages-binary-tree-recur\n  \&quot;Generates passages based on coin flip logic using recursion\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (loop [passages []\n         unprocessed-coords (gen-coords-seq size)]\n    (if (empty? unprocessed-coords)\n      passages\n      (let [coord (first unprocessed-coords)\n            neighbours (-&gt;\n                         (safe-neighbour-coords size coord)\n                         (select-keys [:north :east]))]\n        (if (empty? neighbours)\n          (recur passages (rest unprocessed-coords))\n          (recur (add-passage passages [coord (rand-nth (vals neighbours))]) (rest unprocessed-coords)))))))\n\n(defn gen-passages-binary-tree\n  \&quot;Generates passages based on coin flip logic\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (reduce\n    (fn [passages coord]\n      (let [neighbours (-&gt;\n                         (safe-neighbour-coords size coord)\n                         (select-keys [:north :east]))]\n        (if (empty? neighbours)\n          passages\n          (add-passage passages (vector coord (rand-nth (vals neighbours)))))))\n    [] (gen-coords-seq size)))\n\n(defn gen-passages\n  \&quot;Generates passages using the given algorithm and size\&quot;\n  [algorithm-str size]\n  {:pre  [(s/valid? ::maze-spec/algorithm algorithm-str)\n          (s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (cond\n    (= \&quot;binary-tree-recur\&quot; algorithm-str) (gen-passages-binary-tree-recur size)\n    (= \&quot;binary-tree\&quot;       algorithm-str) (gen-passages-binary-tree size)))\n\n(defn gen-maze\n  \&quot;Generates a maze using the given maze configuration map\&quot;\n  [config]\n  {:pre  [(s/valid? ::maze-spec/maze-config config)]\n   :post [(s/valid? ::maze-spec/maze %)]}\n  {:maze-config config\n   :passages (gen-passages (:algorithm config) (:size config))\n   :generated-at (new java.util.Date)})\n\n(gen-maze {:size {:rows 4 :cols 4} :start [0 0] :goal [3 3] :algorithm \&quot;binary-tree\&quot;})\n\n(defn maze-&gt;string\n  \&quot;Returns a string representation of a maze with the given size and passages\&quot;\n  [maze]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(string? %)]}\n  (let [size (get-in maze [:maze-config :size])\n        passages (:passages maze)]\n    (str\n      \&quot;\\n+\&quot; (apply str (repeat (:cols size) \&quot;---+\&quot;))\n      (reduce\n        (fn [a row]\n          (-&gt;&gt;\n            (reduce\n              (fn [b coord]\n                ; build upon the top string\n                [(str (first b) \&quot;   \&quot; (if (passage-exists-at? passages coord :east) \&quot; \&quot; \&quot;|\&quot;))\n                 ; build upon the bottom string\n                 (str (last b) (if (passage-exists-at? passages coord :south) \&quot;   \&quot; \&quot;---\&quot;) \&quot;*\&quot;)])\n              [\&quot;\\n|\&quot; \&quot;\\n*\&quot;]\n              row)\n            ; join the top and bottom strings\n            (apply str)\n            ; join this row string with the rest of the row strings\n            (str a)))\n        \&quot;\&quot;\n        (gen-coords size)))))&quot;, :offset 7243, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         (println \&quot;neighbour: \&quot; neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2268, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;      (println current)\n      ;(println distances)\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [neighbour (get neighbours coord)]\n                                       (do\n                                         ;(println \&quot;neighbour: \&quot; neighbour)\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance) (&lt; sum distance))\n                                             sum\n                                             distance)))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2328, :ns &quot;solver.core&quot;} {:command &quot;(maze-&gt;string {:maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n               :passages [[[0 0] [0 1]]\n                          [[0 1] [0 2]]\n                          [[0 2] [0 3]]\n                          [[1 0] [1 1]]\n                          [[1 1] [0 1]]\n                          [[1 2] [0 2]]\n                          [[1 3] [0 3]]\n                          [[2 0] [1 0]]\n                          [[2 1] [2 2]]\n                          [[2 2] [2 3]]\n                          [[2 3] [1 3]]\n                          [[3 0] [3 1]]\n                          [[3 1] [3 2]]\n                          [[3 2] [2 2]]\n                          [[3 3] [2 3]]],\n               :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 778, :ns &quot;maze.core&quot;} {:command &quot;(let [distances {:a nil :b nil :c 0 :d nil :e 1 :f nil}\n      kys (keys distances)]\n  (sort-by #(get distances %) kys))&quot;, :offset 119, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [_ (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2133, :ns &quot;solver.core&quot;} {:command &quot;(solve-dijkstra maze)&quot;, :offset 21, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (cond\n    (= maze \&quot;dijkstra\&quot;) (solve-dijkstra maze)))&quot;, :offset 143, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (cond\n    (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze)))&quot;, :offset 148, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance :as kv]]\n                                   (-&gt;&gt;\n                                     (if-let [_ (get neighbours coord)]\n                                       (let [sum (inc current-distance)]\n                                         (println distance)\n                                         (if (or (nil? distance) (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2193, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Returns a sequence of coordinates that describes a path from start to goal using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              current-neighbours (select #(contains? unvisited' %) (get graph current))\n              next (last (sort-by #(get distances %) unvisited))\n              unvisited-graph (reduce-kv (fn [g coord neighbours]\n                                           (assoc g coord (select #(contains? unvisited' %) neighbours)))\n                                         {} graph)]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? (get unvisited-graph current))\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  ;current-neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance]]\n                                   (-&gt;&gt;\n                                     ;; if this coordinate/distance pair is a neighbour of the current coordinate...\n                                     (if-let [_ (get current-neighbours coord)]\n                                       ;; ...update the distance value for it\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance)\n                                                 (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       ;; else, don't change its value\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2607, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Returns a sequence of coordinates that describes a path from start to goal using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (let [graph (passages-&gt;graph passages)]\n\n    ;; solve using recursion\n    (loop [distances (assoc (gen-coords-map size nil) start 0)\n           current start\n           unvisited (apply hash-set (keys graph))]\n\n      ;; if the unvisited coordinates map has been exhausted...\n      (if (empty? unvisited)\n\n        ;; ...return the distances map\n        distances\n\n        ;; else, process the next round\n        (let [unvisited' (disj unvisited current)\n              current-neighbours (select #(contains? unvisited' %) (get graph current))\n              next (last (sort-by #(get distances %) unvisited))]\n\n          ;; if the current coordinate doesn't have any neighbours that are unvisited...\n          (if (empty? current-neighbours)\n\n            ;; ...skip and recur with the current coordinate removed from unvisited\n            (recur distances next unvisited')\n\n            ;; else, build a new distances map for this round\n            (let [current-distance (get distances current)\n                  ;current-neighbours (get unvisited-graph current)\n                  distances' (into {}\n                               (map\n                                 (fn [[coord distance]]\n                                   (-&gt;&gt;\n                                     ;; if this coordinate/distance pair is a neighbour of the current coordinate...\n                                     (if-let [_ (get current-neighbours coord)]\n                                       ;; ...update the distance value for it\n                                       (let [sum (inc current-distance)]\n                                         (if (or (nil? distance)\n                                                 (&lt; sum distance))\n                                           sum\n                                           distance))\n                                       ;; else, don't change its value\n                                       distance)\n                                     (hash-map coord)))\n                                 distances))]\n              (recur distances' next unvisited'))))))))&quot;, :offset 2373, :ns &quot;solver.core&quot;} {:command &quot;(solve-maze maze \&quot;dijkstra\&quot;)&quot;, :offset 28, :ns &quot;solver.core&quot;} {:command &quot;(sort (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 35, :ns &quot;solver.core&quot;} {:command &quot;(sort-by #(println %) (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 51, :ns &quot;solver.core&quot;} {:command &quot;(sort-by #(println %2) (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 52, :ns &quot;solver.core&quot;} {:command &quot;(sort-by (fn [[coord dist]]\n           (println dist)) (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 84, :ns &quot;solver.core&quot;} {:command &quot;(sort-by (fn [[_ dist]] dist) (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 59, :ns &quot;solver.core&quot;} {:command &quot;(split-with #(= \&quot;a\&quot; %) [1 2 3 \&quot;a\&quot; 4 5 6])&quot;, :offset 41, :ns &quot;server.core&quot;} {:command &quot;(split-with #(= \&quot;a\&quot; %) '(1 2 3 \&quot;a\&quot; 4 5 6))&quot;, :offset 42, :ns &quot;server.core&quot;} {:command &quot;(split-with #(prn %) '(1 2 3 \&quot;a\&quot; 4 5 6))&quot;, :offset 40, :ns &quot;server.core&quot;} {:command &quot;(split-with #{\&quot;a\&quot;} '(1 2 3 \&quot;a\&quot; 4 5 6))&quot;, :offset 38, :ns &quot;server.core&quot;} {:command &quot;(split-with #{\&quot;a\&quot;} [1 2 3 \&quot;a\&quot; 4 5 6])&quot;, :offset 37, :ns &quot;server.core&quot;} {:command &quot;(split-with (complement {\&quot;a\&quot;}) [1 2 3 \&quot;a\&quot; 4 5 6])&quot;, :offset 49, :ns &quot;server.core&quot;} {:command &quot;(split-with (complement #{\&quot;a\&quot;}) [1 2 3 \&quot;a\&quot; 4 5 6])&quot;, :offset 50, :ns &quot;server.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Returns a sequence of coordinates that describes a path from start to goal using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages}]\n\n  ;; convert the passages of the maze into a graph-like data structure\n  (-&gt;&gt;\n    (let [graph (passages-&gt;graph passages)]\n\n      ;; solve using recursion\n      (loop [distances (assoc (gen-coords-map size nil) start 0)\n             unvisited (apply hash-set (keys graph))\n             current start]\n\n        ;; if the unvisited coordinates map has been exhausted...\n        (if (empty? unvisited)\n\n          ;; ...return the distances map\n          distances\n\n          ;; else, process the next round\n          (let [unvisited' (disj unvisited current)\n                current-neighbours (select #(contains? unvisited' %) (get graph current))\n                next (last (sort-by #(get distances %) unvisited))]\n\n            ;; if the current coordinate doesn't have any neighbours that are unvisited...\n            (if (empty? current-neighbours)\n\n              ;; ...skip and recur with the current coordinate removed from unvisited\n              (recur distances next unvisited')\n\n              ;; else, build a new distances map for this round\n              (let [current-distance (get distances current)\n                    distances' (into {}\n                                 (map\n                                   (fn [[coord distance]]\n                                     (-&gt;&gt;\n                                       ;; if this coordinate/distance pair is a neighbour of the current coordinate...\n                                       (if-let [_ (get current-neighbours coord)]\n                                         ;; ...update the distance value for it\n                                         (let [sum (inc current-distance)]\n                                           (if (or (nil? distance)\n                                                   (&lt; sum distance))\n                                             sum\n                                             distance))\n                                         ;; else, don't change its value\n                                         distance)\n                                       (hash-map coord)))\n                                   distances))]\n                (recur distances' next unvisited')))))))\n    (sort-by (fn [[_ dist]] dist))))&quot;, :offset 2411, :ns &quot;solver.core&quot;} {:command &quot;(defn dijkstra [g src]\n  (loop [dsts (assoc (zipmap (keys g) (repeat nil)) src 0)\n         curr src\n         unvi (apply hash-set (keys g))]\n    (if (empty? unvi)\n      dsts\n      (let [unvi  (disj unvi curr)\n            nextn (first (sort-by #(% dsts) unvi))\n            nrds  (zipmap (keys g) (map #(select-keys % unvi) (vals g)))]\n        (if (empty? (curr nrds))\n          (recur dsts nextn unvi)\n          (let [cdst  (curr dsts)\n                roads (select-keys (curr g) unvi)\n                reslt (zipmap (keys dsts)\n                              (map #(if-let [rd (% roads)]\n                                      (let [idst (% dsts)\n                                            sum  (+ cdst (% roads))]\n                                        (if (or (nil? idst)\n                                                (&lt; sum idst))\n                                          sum idst))\n                                      (% dsts)) (keys dsts)))]\n            (recur reslt nextn unvi)))))))&quot;, :offset 993, :ns &quot;solver.core&quot;} {:command &quot;(def demo-graph {:red    {:green 10, :blue   5, :orange 8},\n                 :green  {:red 10,   :blue   3},\n                 :blue   {:green 3,  :red    5, :purple 7},\n                 :purple {:blue 7,   :orange 2},\n                 :orange {:purple 2, :red    2}})&quot;, :offset 267, :ns &quot;solver.core&quot;} {:command &quot;(prn (dijkstra demo-graph :red))&quot;, :offset 32, :ns &quot;solver.core&quot;} {:command &quot;(let [q (java.util.PriorityQueue.)\n      (print q)])&quot;, :offset 52, :ns &quot;solver.core&quot;} {:command &quot;(let [q (java.util.PriorityQueue.)]\n  (print q))&quot;, :offset 48, :ns &quot;solver.core&quot;} {:command &quot;(let [q (java.util.PriorityQueue.)]\n  (.add q 1)\n  (.add q 2)\n  (print q))&quot;, :offset 74, :ns &quot;solver.core&quot;} {:command &quot;(let [q (java.util.PriorityQueue.)]\n  (.add q 1)\n  (.add q 2)\n  (.add q 100)\n  (.add q 4)\n  (print q))&quot;, :offset 102, :ns &quot;solver.core&quot;} {:command &quot;(ns maze.core\n  (:require [clojure.spec.alpha :as s]\n            [maze.spec :as maze-spec]))\n\n(defn coord-valid?\n  \&quot;Returns true if the given coordinate is within the boundary dictated by size\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(boolean? %)]}\n  (let [[row col] coord]\n    (and\n      (&lt;= 0 row (dec (:rows size)))\n      (&lt;= 0 col (dec (:cols size))))))\n\n(defn neighbour-coord\n  \&quot;Returns a neighbouring coordinate at the given cardinal direction\&quot;\n  [coord direction]\n  {:pre  [(s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(s/valid? ::maze-spec/coordinate %)]}\n  (cond\n    (= direction :north) (assoc coord 0 (dec (first coord)))\n    (= direction :south) (assoc coord 0 (inc (first coord)))\n    (= direction :east)  (assoc coord 1 (inc (last coord)))\n    (= direction :west)  (assoc coord 1 (dec (last coord)))))\n\n(defn neighbour-coords\n  \&quot;Returns a map of neighbouring coordinates keyed by their cardinal direction\&quot;\n  [coord]\n  {:pre  [(s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/valid? ::maze-spec/neighbour-coordinates %)]}\n  (-&gt;&gt;\n    (map #(neighbour-coord coord %1) [:north :south :east :west])\n    (interleave [:north :south :east :west])\n    (apply hash-map)))\n\n(defn valid-neighbour-coord\n  \&quot;Returns a valid neighbour coordinate, or nil\&quot;\n  [size coord direction]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(s/valid? ::maze-spec/nilable-coordinate %)]}\n  (let [neighbour (neighbour-coord coord direction)]\n    (if (coord-valid? size neighbour)\n      neighbour)))\n\n(defn valid-neighbour-coords\n  \&quot;Returns a map of valid or nil neighbouring coordinates keyed by their cardinal direction\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/valid? ::maze-spec/neighbour-coordinates %)]}\n  (reduce-kv\n    (fn [kvs k _]\n      (assoc kvs k (valid-neighbour-coord size coord k)))\n    {} (neighbour-coords coord)))\n\n(defn safe-neighbour-coords\n  \&quot;Calls valid-neighbour-coords with nil values removed\&quot;\n  [size coord]\n  {:pre  [(s/valid? ::maze-spec/size size)\n          (s/valid? ::maze-spec/coordinate coord)]\n   :post [(s/or ::maze-spec/cardinal-direction ::maze-spec/coordinate)]}\n  (apply merge\n         (for [[k v] (valid-neighbour-coords size coord)\n               :when (not (nil? v))] {k v})))\n\n(defn passage-exists?\n  \&quot;Returns true when passages contains coord-pair or coord-pair reversed\&quot;\n  [passages coord-pair]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate-pair coord-pair)]\n   :post [(or (boolean? %) (nil? %))]}\n  (some\n    #(or (= %1 coord-pair) (= (reverse %1) coord-pair))\n    passages))\n\n(defn passage-exists-at?\n  \&quot;Returns true when passages contains a pairing of the given coord and a neighbour of it\&quot;\n  [passages coord direction]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate coord)\n          (s/valid? ::maze-spec/cardinal-direction direction)]\n   :post [(or (boolean? %) (nil? %))]}\n  (passage-exists? passages (vector coord (neighbour-coord coord direction))))\n\n(defn add-passage\n  \&quot;Adds a passage between coord-pair to the given passages vector\&quot;\n  [passages coord-pair]\n  {:pre  [(s/valid? ::maze-spec/passages passages)\n          (s/valid? ::maze-spec/coordinate-pair coord-pair)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (if (not (passage-exists? passages coord-pair))\n    (conj passages coord-pair)\n    passages))\n\n(defn gen-coords\n  \&quot;Generates a 2d vector of coordinates that covers all points of a grid with the given size\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/coordinate-vector-2d %)]}\n  (into [] (for [row (range (:rows size))]\n    (into [] (for [col (range (:cols size))]\n      [row col])))))\n\n(defn gen-coords-seq\n  \&quot;Returns gen-cords as a sequence of coordinates\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/coordinate-seq %)]}\n  (map vec (partition 2 (flatten (gen-coords size)))))\n\n(defn gen-passages-binary-tree-recur\n  \&quot;Generates passages based on coin flip logic using recursion\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (loop [passages []\n         unprocessed-coords (gen-coords-seq size)]\n    (if (empty? unprocessed-coords)\n      passages\n      (let [coord (first unprocessed-coords)\n            neighbours (-&gt;\n                         (safe-neighbour-coords size coord)\n                         (select-keys [:north :east]))]\n        (if (empty? neighbours)\n          (recur passages (rest unprocessed-coords))\n          (recur (add-passage passages [coord (rand-nth (vals neighbours))]) (rest unprocessed-coords)))))))\n\n(defn gen-passages-binary-tree\n  \&quot;Generates passages based on coin flip logic\&quot;\n  [size]\n  {:pre  [(s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (reduce\n    (fn [passages coord]\n      (let [neighbours (-&gt;\n                         (safe-neighbour-coords size coord)\n                         (select-keys [:north :east]))]\n        (if (empty? neighbours)\n          passages\n          (add-passage passages (vector coord (rand-nth (vals neighbours)))))))\n    [] (gen-coords-seq size)))\n\n(defn gen-passages\n  \&quot;Generates passages using the given algorithm and size\&quot;\n  [algorithm-str size]\n  {:pre  [(s/valid? ::maze-spec/algorithm algorithm-str)\n          (s/valid? ::maze-spec/size size)]\n   :post [(s/valid? ::maze-spec/passages %)]}\n  (cond\n    (= \&quot;binary-tree-recur\&quot; algorithm-str) (gen-passages-binary-tree-recur size)\n    (= \&quot;binary-tree\&quot;       algorithm-str) (gen-passages-binary-tree size)))\n\n(defn gen-maze\n  \&quot;Generates a maze using the given maze configuration map\&quot;\n  [config]\n  {:pre  [(s/valid? ::maze-spec/maze-config config)]\n   :post [(s/valid? ::maze-spec/maze %)]}\n  {:maze-config config\n   :passages (gen-passages (:algorithm config) (:size config))\n   :generated-at (new java.util.Date)})\n\n(gen-maze {:size {:rows 4 :cols 4} :start [0 0] :goal [3 3] :algorithm \&quot;binary-tree\&quot;})\n\n(defn maze-&gt;string\n  \&quot;Returns a string representation of a maze with the given size and passages\&quot;\n  [maze]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(string? %)]}\n  (let [size (get-in maze [:maze-config :size])\n        passages (:passages maze)]\n    (str\n      \&quot;\\n+\&quot; (apply str (repeat (:cols size) \&quot;---+\&quot;))\n      (reduce\n        (fn [a row]\n          (-&gt;&gt;\n            (reduce\n              (fn [b coord]\n                ; build upon the top string\n                [(str (first b) \&quot;   \&quot; (if (passage-exists-at? passages coord :east) \&quot; \&quot; \&quot;|\&quot;))\n                 ; build upon the bottom string\n                 (str (last b) (if (passage-exists-at? passages coord :south) \&quot;   \&quot; \&quot;---\&quot;) \&quot;*\&quot;)])\n              [\&quot;\\n|\&quot; \&quot;\\n*\&quot;]\n              row)\n            ; join the top and bottom strings\n            (apply str)\n            ; join this row string with the rest of the row strings\n            (str a)))\n        \&quot;\&quot;\n        (gen-coords size)))))\n\n(maze-&gt;string {:maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n               :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[1 0] [1 1]] [[1 1] [0 1]] [[1 2] [0 2]] [[1 3] [0 3]] [[2 0] [1 0]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[3 0] [3 1]] [[3 1] [3 2]] [[3 2] [2 2]] [[3 3] [2 3]]], :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 7644, :ns &quot;server.core&quot;} {:command &quot;'([2 0] [1 0] [1 1] [0 1] [0 2] [0 3] [1 3] [2 3] [2 2] [3 2] [3 1] [3 0])&quot;, :offset 74, :ns &quot;server.core&quot;} {:command &quot;({:_id #object[org.bson.types.ObjectId 0x6662a41f \&quot;5e7d8a1b2a799f096a4c5432\&quot;], :maze-config {:size {:rows 5, :cols 5}, :start [0 0], :goal [4 4], :algorithm \&quot;binary-tree\&quot;}, :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[0 3] [0 4]] [[1 0] [0 0]] [[1 1] [1 2]] [[1 2] [1 3]] [[1 3] [0 3]] [[1 4] [0 4]] [[2 0] [2 1]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[2 4] [1 4]] [[3 0] [2 0]] [[3 1] [2 1]] [[3 2] [3 3]] [[3 3] [3 4]] [[3 4] [2 4]] [[4 0] [3 0]] [[4 1] [3 1]] [[4 2] [4 3]] [[4 3] [4 4]] [[4 4] [3 4]]], :generated-at #inst \&quot;2020-03-27T05:07:39.224-00:00\&quot;})&quot;, :offset 575, :ns &quot;server.core&quot;} {:command &quot;(def mazes '({:_id #object[org.bson.types.ObjectId 0x6662a41f \&quot;5e7d8a1b2a799f096a4c5432\&quot;], :maze-config {:size {:rows 5, :cols 5}, :start [0 0], :goal [4 4], :algorithm \&quot;binary-tree\&quot;}, :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[0 3] [0 4]] [[1 0] [0 0]] [[1 1] [1 2]] [[1 2] [1 3]] [[1 3] [0 3]] [[1 4] [0 4]] [[2 0] [2 1]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[2 4] [1 4]] [[3 0] [2 0]] [[3 1] [2 1]] [[3 2] [3 3]] [[3 3] [3 4]] [[3 4] [2 4]] [[4 0] [3 0]] [[4 1] [3 1]] [[4 2] [4 3]] [[4 3] [4 4]] [[4 4] [3 4]]], :generated-at #inst \&quot;2020-03-27T05:07:39.224-00:00\&quot;}))&quot;, :offset 588, :ns &quot;server.core&quot;} {:command &quot;(def mazes '({:_id #object[org.bson.types.ObjectId 0x6662a41f \&quot;5e7d8a1b2a799f096a4c5432\&quot;], :maze-config {:size {:rows 5, :cols 5}, :start [0 0], :goal [4 4], :algorithm \&quot;binary-tree\&quot;}, :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[0 3] [0 4]] [[1 0] [0 0]] [[1 1] [1 2]] [[1 2] [1 3]] [[1 3] [0 3]] [[1 4] [0 4]] [[2 0] [2 1]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[2 4] [1 4]] [[3 0] [2 0]] [[3 1] [2 1]] [[3 2] [3 3]] [[3 3] [3 4]] [[3 4] [2 4]] [[4 0] [3 0]] [[4 1] [3 1]] [[4 2] [4 3]] [[4 3] [4 4]] [[4 4] [3 4]]], :generated-at #inst \&quot;2020-03-27T05:07:39.224-00:00\&quot;}))\n&quot;, :offset 589, :ns &quot;server.core&quot;} {:command &quot;(def mazes '({:_id 6969, :maze-config {:size {:rows 5, :cols 5}, :start [0 0], :goal [4 4], :algorithm \&quot;binary-tree\&quot;}, :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[0 3] [0 4]] [[1 0] [0 0]] [[1 1] [1 2]] [[1 2] [1 3]] [[1 3] [0 3]] [[1 4] [0 4]] [[2 0] [2 1]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[2 4] [1 4]] [[3 0] [2 0]] [[3 1] [2 1]] [[3 2] [3 3]] [[3 3] [3 4]] [[3 4] [2 4]] [[4 0] [3 0]] [[4 1] [3 1]] [[4 2] [4 3]] [[4 3] [4 4]] [[4 4] [3 4]]], :generated-at \&quot;2020-03-27T05:07:39.224-00:00\&quot;}))\n&quot;, :offset 516, :ns &quot;server.core&quot;} {:command &quot;(map (fn [maze]\n       (assoc maze :_id (str (:_id maze))))\n     mazes)&quot;, :offset 71, :ns &quot;server.core&quot;} {:command &quot;(defn get-maze\n  \&quot;Returns a single maze\&quot;\n  [database id]\n  (let [maze (mc/find-one-as-map database maze-collection-name id)]\n    (generate-string {:maze (assoc maze :_id (str (:_id maze)))})))&quot;, :offset 192, :ns &quot;server.handlers&quot;} {:command &quot;(-main)&quot;, :offset 7, :ns &quot;server.core&quot;} {:command &quot;(maze-&gt;string {:maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n               :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[1 0] [1 1]] [[1 1] [0 1]] [[1 2] [0 2]] [[1 3] [0 3]] [[2 0] [1 0]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[3 0] [3 1]] [[3 1] [3 2]] [[3 2] [2 2]] [[3 3] [2 3]]], :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 399, :ns &quot;maze.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Maze REPL">
    <configuration name="Maze REPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="server" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration name="Server REPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="server" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.Server REPL" />
      <item itemvalue="Clojure REPL.Maze REPL" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="0f65cb7c-ce96-4e56-a495-a59f1aa4fadb" name="Default Changelist" comment="" />
      <created>1584461944928</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1584461944928</updated>
    </task>
    <servers />
  </component>
</project>