<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="d8b76d46-8a30-41b4-b195-b0d8be12781b" name="Default Changelist" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ProjectId" id="1ZrCVYQQEXJXkpSQynwb3yxbWkN" />
  <component name="PropertiesComponent">
    <property name="last_opened_file_path" value="$PROJECT_DIR$/resources/html" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/resources/html" />
    </key>
  </component>
  <component name="ReplState" timestamp="1585833477537">{:repl-history {:ide [], :local [{:command &quot;(client.core/-main)&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(sto-app)&quot;, :offset 9, :ns &quot;client.core&quot;} {:command &quot;(stop-app)&quot;, :offset 10, :ns &quot;client.core&quot;} {:command &quot;(start-app)&quot;, :offset 11, :ns &quot;client.core&quot;} {:command &quot;(defn -main [&amp; args]\n  (start-app args))&quot;, :offset 40, :ns &quot;client.core&quot;} {:command &quot;(ns client.core\n  (:require\n    [client.handler :as handler]\n    [client.nrepl :as nrepl]\n    [luminus.http-server :as http]\n    [client.config :refer [env]]\n    [clojure.tools.cli :refer [parse-opts]]\n    [clojure.tools.logging :as log]\n    [mount.core :as mount])\n  (:gen-class))\n\n;; log uncaught exceptions in threads\n(Thread/setDefaultUncaughtExceptionHandler\n  (reify Thread$UncaughtExceptionHandler\n    (uncaughtException [_ thread ex]\n      (log/error {:what :uncaught-exception\n                  :exception ex\n                  :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n(def cli-options\n  [[\&quot;-p\&quot; \&quot;--port PORT\&quot; \&quot;Port number\&quot;\n    :parse-fn #(Integer/parseInt %)]])\n\n(mount/defstate ^{:on-reload :noop} http-server\n  :start\n  (http/start\n    (-&gt; env\n        (assoc  :handler (handler/app))\n        (update :port #(or (-&gt; env :options :port) %))))\n  :stop\n  (http/stop http-server))\n\n(mount/defstate ^{:on-reload :noop} repl-server\n  :start\n  (when (env :nrepl-port)\n    (nrepl/start {:bind (env :nrepl-bind)\n                  :port (env :nrepl-port)}))\n  :stop\n  (when repl-server\n    (nrepl/stop repl-server)))\n\n\n(defn stop-app []\n  (doseq [component (:stopped (mount/stop))]\n    (log/info component \&quot;stopped\&quot;))\n  (shutdown-agents))\n\n(defn start-app [args]\n  (doseq [component (-&gt; args\n                        (parse-opts cli-options)\n                        mount/start-with-args\n                        :started)]\n    (log/info component \&quot;started\&quot;))\n  (.addShutdownHook (Runtime/getRuntime) (Thread. stop-app)))\n\n(defn -main [&amp; args]\n  (start-app args))\n\n&quot;, :offset 1582, :ns &quot;user&quot;} {:command &quot;{:reitit.core/match #reitit.core.Match{:template \&quot;/test/:id\&quot;, :data {:middleware [#object[client.middleware$wrap_csrf 0x6c21cc0a \&quot;client.middleware$wrap_csrf@6c21cc0a\&quot;] #object[client.middleware$wrap_formats 0xb1fdc87 \&quot;client.middleware$wrap_formats@b1fdc87\&quot;]], :get {:handler #object[client.routes.home$test_page 0x182d4cdb \&quot;client.routes.home$test_page@182d4cdb\&quot;]}}, :result #reitit.ring.Methods{:get #reitit.ring.Endpoint{:data {:middleware [#object[client.middleware$wrap_csrf 0x6c21cc0a \&quot;client.middleware$wrap_csrf@6c21cc0a\&quot;] #object[client.middleware$wrap_formats 0xb1fdc87 \&quot;client.middleware$wrap_formats@b1fdc87\&quot;]], :handler #object[client.routes.home$test_page 0x182d4cdb \&quot;client.routes.home$test_page@182d4cdb\&quot;]}, :handler #object[ring.middleware.anti_forgery$wrap_anti_forgery$fn__7076 0x4eeba3d7 \&quot;ring.middleware.anti_forgery$wrap_anti_forgery$fn__7076@4eeba3d7\&quot;], :path \&quot;/test/:id\&quot;, :method :get, :middleware [#reitit.middleware.Middleware{:name nil, :wrap #object[client.middleware$wrap_csrf 0x6c21cc0a \&quot;client.middleware$wrap_csrf@6c21cc0a\&quot;], :spec nil} #reitit.middleware.Middleware{:name nil, :wrap #object[client.middleware$wrap_formats 0xb1fdc87 \&quot;client.middleware$wrap_formats@b1fdc87\&quot;], :spec nil}]}, :head nil, :post nil, :put nil, :delete nil, :connect nil, :options #reitit.ring.Endpoint{:data {:middleware [#object[client.middleware$wrap_csrf 0x6c21cc0a \&quot;client.middleware$wrap_csrf@6c21cc0a\&quot;] #object[client.middleware$wrap_formats 0xb1fdc87 \&quot;client.middleware$wrap_formats@b1fdc87\&quot;]], :no-doc true, :handler #object[reitit.ring$fn__10915$fn__10924 0x495c6d4a \&quot;reitit.ring$fn__10915$fn__10924@495c6d4a\&quot;]}, :handler #object[ring.middleware.anti_forgery$wrap_anti_forgery$fn__7076 0x26254912 \&quot;ring.middleware.anti_forgery$wrap_anti_forgery$fn__7076@26254912\&quot;], :path \&quot;/test/:id\&quot;, :method :options, :middleware [#reitit.middleware.Middleware{:name nil, :wrap #object[client.middleware$wrap_csrf 0x6c21cc0a \&quot;client.middleware$wrap_csrf@6c21cc0a\&quot;], :spec nil} #reitit.middleware.Middleware{:name nil, :wrap #object[client.middleware$wrap_formats 0xb1fdc87 \&quot;client.middleware$wrap_formats@b1fdc87\&quot;], :spec nil}]}, :trace nil, :patch nil}, :path-params {:id \&quot;123\&quot;}, :path \&quot;/test/123\&quot;}, :reitit.core/router #object[reitit.core$mixed_router$reify__10577 0x5e6acc9 \&quot;reitit.core$mixed_router$reify__10577@5e6acc9\&quot;], :ssl-client-cert nil, :protocol \&quot;HTTP/1.1\&quot;, :cookies {\&quot;ring-session\&quot; {:value \&quot;15ae8723-f2ee-489b-8a76-ea2a81965b1b\&quot;}}, :remote-addr \&quot;127.0.0.1\&quot;, :params {}, :flash nil, :headers {\&quot;sec-fetch-site\&quot; \&quot;none\&quot;, \&quot;host\&quot; \&quot;127.0.0.1:3000\&quot;, \&quot;user-agent\&quot; \&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\&quot;, \&quot;cookie\&quot; \&quot;ring-session=15ae8723-f2ee-489b-8a76-ea2a81965b1b\&quot;, \&quot;sec-fetch-user\&quot; \&quot;?1\&quot;, \&quot;connection\&quot; \&quot;keep-alive\&quot;, \&quot;upgrade-insecure-requests\&quot; \&quot;1\&quot;, \&quot;accept\&quot; \&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\&quot;, \&quot;accept-language\&quot; \&quot;en-GB,en;q=0.9\&quot;, \&quot;sec-fetch-dest\&quot; \&quot;document\&quot;, \&quot;accept-encoding\&quot; \&quot;gzip, deflate, br\&quot;, \&quot;sec-fetch-mode\&quot; \&quot;navigate\&quot;, \&quot;dnt\&quot; \&quot;1\&quot;, \&quot;cache-control\&quot; \&quot;max-age=0\&quot;}, :server-port 3000, :muuntaja/request nil, :content-length nil, :form-params {}, :session/key nil, :query-params {}, :content-type nil, :character-encoding nil, :uri \&quot;/test/123\&quot;, :server-name \&quot;127.0.0.1\&quot;, :anti-forgery-token \&quot;kJDzp3PaXORqwQjTBlEzTdW//x+EkO16CwX9Ouc0BCGtGVJWuZ+iQ4P9H2JfkDkpLLd0Pkixh8bo2tdB\&quot;, :query-string nil, :path-params {:id \&quot;123\&quot;}, :muuntaja/response #FormatAndCharset{:format \&quot;application/json\&quot;, :charset \&quot;utf-8\&quot;, :raw-format \&quot;text/html\&quot;}, :body #object[org.eclipse.jetty.server.HttpInputOverHTTP 0x570bb897 \&quot;HttpInputOverHTTP@570bb897[c=0,q=0,[0]=null,s=STREAM]\&quot;], :multipart-params {}, :scheme :http, :request-method :get, :session {}}&quot;, :offset 3814, :ns &quot;user&quot;} {:command &quot;*ns*&quot;, :offset 4, :ns &quot;user&quot;} {:command &quot;(-main)&quot;, :offset 7, :ns &quot;client.core&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]))\n\n(def maze {:maze-config {:size {:rows 4, :cols 4}, :start [2 0], :goal [3 0], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn gen-coords\n  \&quot;Generates a 2d vector of coordinates that covers all points of a grid with the given size\&quot;\n  [size]\n\n  (into [] (for [row (range (:rows size))]\n             (into [] (for [col (range (:cols size))]\n                        [row col])))))\n\n(defn gen-coords-seq\n  \&quot;Returns gen-cords as a sequence of coordinates\&quot;\n  [size]\n  (map vec (partition 2 (flatten (gen-coords size)))))\n\n(defn gen-coords-map\n  \&quot;Generates a map keyed by coordinates with values initialised to default\&quot;\n  [size default]\n  (zipmap (gen-coords-seq size) (repeat default)))\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map for all coordinates in range size\&quot;\n  [size]\n  (merge\n    (priority-map-keyfn #(:distance %))\n    (gen-coords-map size {:distance ##Inf :via nil})))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map size) [start :distance] 0)\n           doneq (gen-priority-map {:rows 0 :cols 0})]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course if there are no unvisited neighbours\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map]\n  (loop [map priority-map\n         path [(last (keys map))]\n         current (last map)]\n    (if (empty? map)\n      (reverse path)\n      (let [[coord {via :via}] current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (apply vec (select-keys map [via]))))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path)))&quot;, :offset 4776, :ns &quot;user&quot;} {:command &quot;(passages-&gt;graph (:passages maze))&quot;, :offset 34, :ns &quot;solver.core&quot;} {:command &quot;(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  [graph]\n  (merge\n    (priority-map-keyfn #(:distance %))\n    (zipmap (keys graph) (repeat ##Inf))))&quot;, :offset 174, :ns &quot;solver.core&quot;} {:command &quot;(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  [graph]\n  (merge\n    (priority-map-keyfn #(:distance %))\n    (zipmap (keys graph) (repeat {:distance ##Inf :via nil}))))&quot;, :offset 195, :ns &quot;solver.core&quot;} {:command &quot;(gen-priority-map (passages-&gt;graph (:passages maze)))&quot;, :offset 53, :ns &quot;solver.core&quot;} {:command &quot;(defn gen-priority-map'\n  \&quot;Generates a priority map for all coordinates in range size\&quot;\n  [size]\n  (merge\n    (priority-map-keyfn #(:distance %))\n    (gen-coords-map size {:distance ##Inf :via nil})))&quot;, :offset 199, :ns &quot;solver.core&quot;} {:command &quot;(gen-priority-map' (get-in maze [:maze-config :size]))&quot;, :offset 54, :ns &quot;solver.core&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]))\n\n(def maze {:maze-config {:size {:rows 4, :cols 4}, :start [2 0], :goal [3 0], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  [graph]\n  (merge\n    (priority-map-keyfn #(:distance %))\n    (zipmap (keys graph) (repeat {:distance ##Inf :via nil}))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map size) [start :distance] 0)\n           doneq (gen-priority-map {:rows 0 :cols 0})]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course if there are no unvisited neighbours\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map]\n  (loop [map priority-map\n         path [(last (keys map))]\n         current (last map)]\n    (if (empty? map)\n      (reverse path)\n      (let [[coord {via :via}] current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (apply vec (select-keys map [via]))))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path)))\n\n;(solve-maze maze \&quot;dijkstra\&quot;)&quot;, :offset 4243, :ns &quot;user&quot;} {:command &quot;(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))&quot;, :offset 246, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course if there are no unvisited neighbours\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2290, :ns &quot;solver.core&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]))\n\n(def maze {:maze-config {:size {:rows 4, :cols 4}, :start [2 0], :goal [3 0], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{size :size start :start goal :goal} :maze-config passages :passages :as maze}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course if there are no unvisited neighbours\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n;(solve-dijkstra maze)\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map]\n  (loop [map priority-map\n         path [(last (keys map))]\n         current (last map)]\n    (if (empty? map)\n      (reverse path)\n      (let [[coord {via :via}] current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (apply vec (select-keys map [via]))))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path)))&quot;, :offset 4270, :ns &quot;user&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2233, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          (prn \&quot;coord\&quot; coord)\n          (prn \&quot;goal\&quot; goal)\n          (prn \&quot;coord==goal\&quot; (= coord goal))\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2336, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;(prn \&quot;coord\&quot; coord)\n          ;(prn \&quot;goal\&quot; goal)\n          ;(prn \&quot;coord==goal\&quot; (= coord goal))\n          (prn \&quot;doneq\&quot; doneq)\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2369, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;(prn \&quot;coord\&quot; coord)\n          ;(prn \&quot;goal\&quot; goal)\n          ;(prn \&quot;coord==goal\&quot; (= coord goal))\n          ;(prn \&quot;doneq\&quot; doneq)\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2370, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;(prn \&quot;coord\&quot; coord)\n          ;(prn \&quot;goal\&quot; goal)\n          ;(prn \&quot;coord==goal\&quot; (= coord goal))\n          ;(prn \&quot;doneq\&quot; doneq)\n          (prn \&quot;fqueue\&quot; (first queue))\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2409, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages}]\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;(prn \&quot;coord\&quot; coord)\n          ;(prn \&quot;goal\&quot; goal)\n          ;(prn \&quot;coord==goal\&quot; (= coord goal))\n          ;(prn \&quot;doneq\&quot; doneq)\n          ;(prn \&quot;fqueue\&quot; (first queue))\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2410, :ns &quot;solver.core&quot;} {:command &quot;(solve-dijkstra maze)&quot;, :offset 21, :ns &quot;solver.core&quot;} {:command &quot;(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via))))\n      )\n\n   ))&quot;, :offset 457, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path ((get-in maze [:maze-config :goal])))))&quot;, :offset 221, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path (get-in maze [:maze-config :goal]))))&quot;, :offset 219, :ns &quot;solver.core&quot;} {:command &quot;(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (prn \&quot;current\&quot; current)\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via))))\n      )\n\n   ))&quot;, :offset 485, :ns &quot;solver.core&quot;} {:command &quot;(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (prn \&quot;path\&quot; path)\n    (prn \&quot;current\&quot; current)\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via))))\n      )\n\n   ))&quot;, :offset 507, :ns &quot;solver.core&quot;} {:command &quot;(def maze {:maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 710, :ns &quot;solver.core&quot;} {:command &quot;(every? str? [\&quot;a\&quot;])&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(every? int? [\&quot;a\&quot;])&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(every? int? [1 1])&quot;, :offset 19, :ns &quot;user&quot;} {:command &quot;(every? (fn [x] (= x 1)) [1 1])&quot;, :offset 31, :ns &quot;user&quot;} {:command &quot;(every? (fn [x] (= x 1)) {:a 1 :b 2})&quot;, :offset 37, :ns &quot;user&quot;} {:command &quot;(every? (fn [[k v] x] (prn k)) {:a 1 :b 2})&quot;, :offset 43, :ns &quot;user&quot;} {:command &quot;(every? (fn [[[k v] x]] (prn k)) {:a 1 :b 2})&quot;, :offset 45, :ns &quot;user&quot;} {:command &quot;(every? (fn [[k v]] (prn k)) {:a 1 :b 2})&quot;, :offset 41, :ns &quot;user&quot;} {:command &quot;(every? (fn [[k v]] (keyword? k)) {:a 1 :b 2})&quot;, :offset 46, :ns &quot;user&quot;} {:command &quot;(every? (fn [[k v]] (keyword? k)) {:a 1 :b 2 [0 0] \&quot;a\&quot;})&quot;, :offset 56, :ns &quot;user&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [k _] (s/valid? ::maze-spec/coordinate k)) %)))&quot;, :offset 109, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.spec\n  (:require [maze.spec :as maze-spec]\n            [clojure.spec.alpha :as s]))\n\n(s/def ::graph (s/and map?\n                      #(every? (fn [k _] (s/valid? ::maze-spec/coordinate k)) %)))&quot;, :offset 205, :ns &quot;user&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k _]] (s/valid? ::maze-spec/coordinate k)) %)))&quot;, :offset 111, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::graph {[0 0] 1})&quot;, :offset 28, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::graph {[0 0] 1 :foo 1})&quot;, :offset 35, :ns &quot;solver.spec&quot;} {:command &quot;{(s/valid? ::graph {[0 0] 1})}&quot;, :offset 30, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (s/coll-of ::coordinate)) %)))&quot;, :offset 202, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (s/coll-of ::coordinate v)) %)))&quot;, :offset 204, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (prn v)\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (s/coll-of ::coordinate v)) %)))&quot;, :offset 245, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [x]\n                                 (prn x)\n                                 (s/valid? ::maze-spec/coordinate x)\n                                 ;(s/coll-of ::coordinate v)\n                                 ) %)))&quot;, :offset 276, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[x]]\n                                 (prn x)\n                                 (s/valid? ::maze-spec/coordinate x)\n                                 ;(s/coll-of ::coordinate v)\n                                 ) %)))&quot;, :offset 278, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (prn k)\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 ;(s/coll-of ::coordinate v)\n                                 ) %)))&quot;, :offset 280, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (prn k)\n                                 (prn v)\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 ;(s/coll-of ::coordinate v)\n                                 ) %)))&quot;, :offset 321, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v]]\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (s/coll-of ::maze-spec/coordinate v)) %)))&quot;, :offset 214, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v :as kv]]\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (s/coll-of ::maze-spec/coordinate v)) %)))&quot;, :offset 221, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v :as kv]]\n                                 (prn kv)\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 ;(s/coll-of ::maze-spec/coordinate v)\n                                 ) %)))&quot;, :offset 298, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/and map?\n                      #(every? (fn [[k v :as kv]]\n                                 (prn kv)\n                                 (s/valid? ::maze-spec/coordinate k)\n                                 (prn v)\n                                 ;(s/coll-of ::maze-spec/coordinate v)\n                                 ) %)))&quot;, :offset 339, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::graph (s/every-kv ::maze-spec/coordinate (s/coll-of ::maze-spec/coordinate)))&quot;, :offset 86, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::graph {[0 0] 1 })&quot;, :offset 29, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::graph {[0 0] #{[0 1]} })&quot;, :offset 36, :ns &quot;solver.spec&quot;} {:command &quot;\n(s/def ::via ::maze-spec/coordinate)\n(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))&quot;, :offset 147, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::priority-map-item {:distance 0 :via [0 0 0]})&quot;, :offset 57, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::priority-map-item {:distance \&quot;0\&quot; :via [0 0]})&quot;, :offset 57, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance -1)&quot;, :offset 24, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance \&quot;0\&quot;)&quot;, :offset 25, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance [0])&quot;, :offset 25, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance pos-int?)&quot;, :offset 27, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::priority-map-item {:distance [1] :via [0 0]})&quot;, :offset 57, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/or #(= 0 %) pos-int?))&quot;, :offset 43, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/or pos-int? #(= 0 %) ))&quot;, :offset 44, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or pos-int? #(= 0 %) ))&quot;, :offset 42, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance int?)&quot;, :offset 23, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::via ::maze-spec/coordinate)&quot;, :offset 36, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))&quot;, :offset 109, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::priority-map-item {:distance 0 :via [0 0]})&quot;, :offset 55, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.spec\n  (:require [maze.spec :as maze-spec]\n            [clojure.spec.alpha :as s]))\n\n;; a graph generated from maze passages\n(s/def ::graph (s/every-kv ::maze-spec/coordinate (s/coll-of ::maze-spec/coordinate)))\n\n;; an item within a priority map\n(s/def ::distance int?)\n(s/def ::via ::maze-spec/coordinate)\n(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))\n\n;; a priority map\n(s/def ::priority-map (s/every-kv ::maze-spec/coordinate ::priority-map-item))&quot;, :offset 525, :ns &quot;user&quot;} {:command &quot;(type (solve-maze maze \&quot;dijkstra\&quot;))&quot;, :offset 35, :ns &quot;solver.core&quot;} {:command &quot;(s/valid? ::coord-seq [[0 1]])&quot;, :offset 30, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::coord-seq '([0 1]))&quot;, :offset 31, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::coord-seq (s/and seq? (s/coll-of ::maze-spec/coordinate)))&quot;, :offset 67, :ns &quot;solver.spec&quot;} {:command &quot;(ns maze.spec\n  (:require [clojure.spec.alpha :as s]))\n\n;; cardinal direction keys\n(s/def ::cardinal-direction #{:north :south :east :west})\n\n;; size map with rows and cols\n(s/def ::size (s/map-of #{:rows :cols} pos-int?))\n\n;; coordinate vector\n(s/def ::coordinate (s/and vector?\n                           (s/coll-of int?)\n                           #(= 2 (count %))))\n\n;; nilable coordinate vector\n(s/def ::nilable-coordinate (s/nilable ::coordinate))\n\n;; a pair of coordinates\n(s/def ::coordinate-pair (s/and vector?\n                                (s/coll-of ::coordinate)\n                                #(= 2 (count %))))\n\n;; a sequence of coordinates\n(s/def ::coordinate-seq (s/and seq?\n                               (s/coll-of ::coordinate)))\n\n;; a vector of coordinates\n(s/def ::coordinate-vector (s/and vector?\n                                  (s/coll-of ::coordinate)))\n\n;; a 2d vector of coordinates\n(s/def ::coordinate-vector-2d (s/and vector?\n                                     (s/coll-of ::coordinate-vector)))\n\n;; neighbour coordinate map\n(s/def ::neighbour-coordinates (s/map-of #{:north :south :east :west} ::nilable-coordinate))\n\n;; maze configuration map\n(s/def ::start ::coordinate)\n(s/def ::goal ::coordinate)\n(s/def ::algorithm #{\&quot;binary-tree-recur\&quot; \&quot;binary-tree\&quot;})\n(s/def ::maze-config (s/keys :req-un [::size ::start ::goal ::algorithm]\n                             :opt-un []))\n\n;; maze passages\n(s/def ::passages (s/and vector?\n                         (s/coll-of ::coordinate-pair)))\n\n;; maze map\n(s/def ::_id string?)\n(s/def ::generated-at #(instance? java.util.Date %))\n(s/def ::maze (s/keys :req-un [::maze-config ::passages]\n                      :opt-un [::_id ::generated-at]))&quot;, :offset 1715, :ns &quot;user&quot;} {:command &quot;(s/valid? ::maze maze)&quot;, :offset 22, :ns &quot;maze.spec&quot;} {:command &quot;(s/exaplin ::maze maze)&quot;, :offset 23, :ns &quot;maze.spec&quot;} {:command &quot;(ns maze.spec\n                                                                      (:require [clojure.spec.alpha :as s]))\n\n;; cardinal direction keys\n(s/def ::cardinal-direction #{:north :south :east :west})\n\n;; size map with rows and cols\n(s/def ::size (s/map-of #{:rows :cols} pos-int?))\n\n;; coordinate vector\n(s/def ::coordinate (s/and vector?\n                           (s/coll-of int?)\n                           #(= 2 (count %))))\n\n;; nilable coordinate vector\n(s/def ::nilable-coordinate (s/nilable ::coordinate))\n\n;; a pair of coordinates\n(s/def ::coordinate-pair (s/and vector?\n                                (s/coll-of ::coordinate)\n                                #(= 2 (count %))))\n\n;; a sequence of coordinates\n(s/def ::coordinate-seq (s/and seq?\n                               (s/coll-of ::coordinate)))\n\n;; a vector of coordinates\n(s/def ::coordinate-vector (s/and vector?\n                                  (s/coll-of ::coordinate)))\n\n;; a 2d vector of coordinates\n(s/def ::coordinate-vector-2d (s/and vector?\n                                     (s/coll-of ::coordinate-vector)))\n\n;; neighbour coordinate map\n(s/def ::neighbour-coordinates (s/map-of #{:north :south :east :west} ::nilable-coordinate))\n\n;; maze configuration map\n(s/def ::start ::coordinate)\n(s/def ::goal ::coordinate)\n(s/def ::algorithm #{\&quot;binary-tree-recur\&quot; \&quot;binary-tree\&quot;})\n(s/def ::maze-config (s/keys :req-un [::size ::start ::goal ::algorithm]\n                             :opt-un []))\n\n;; maze passages\n(s/def ::passages (s/and vector?\n                         (s/coll-of ::coordinate-pair)))\n\n;; maze map\n(s/def ::_id string?)\n(s/def ::generated-at #(instance? java.util.Date %))\n(s/def ::maze (s/keys :req-un [::maze-config ::passages]\n                      :opt-un [::_id ::generated-at]))\n\n(def maze {:_id \&quot;5e7d8a1b2a799f096a4c5432\&quot;, :maze-config {:size {:rows 5, :cols 5}, :start [0 0], :goal [4 4], :algorithm \&quot;binary-tree\&quot;}, :passages [[[0 0] [0 1]] [[0 1] [0 2]] [[0 2] [0 3]] [[0 3] [0 4]] [[1 0] [0 0]] [[1 1] [1 2]] [[1 2] [1 3]] [[1 3] [0 3]] [[1 4] [0 4]] [[2 0] [2 1]] [[2 1] [2 2]] [[2 2] [2 3]] [[2 3] [1 3]] [[2 4] [1 4]] [[3 0] [2 0]] [[3 1] [2 1]] [[3 2] [3 3]] [[3 3] [3 4]] [[3 4] [2 4]] [[4 0] [3 0]] [[4 1] [3 1]] [[4 2] [4 3]] [[4 3] [4 4]] [[4 4] [3 4]]], :generated-at \&quot;2020-03-27T05:07:39Z\&quot;})\n\n(s/explain ::maze maze)&quot;, :offset 2335, :ns &quot;user&quot;} {:command &quot;(s/def ::generated-at (or string? #(instance? java.util.Date %)))&quot;, :offset 65, :ns &quot;maze.spec&quot;} {:command &quot;(s/explain ::maze maze)&quot;, :offset 23, :ns &quot;maze.spec&quot;} {:command &quot;(ns solver.spec\n  (:require [maze.spec :as maze-spec]\n            [clojure.spec.alpha :as s]))\n\n;; allowed algorithms for solving\n(s/def ::algorithm #{\&quot;dijkstra\&quot;})\n\n;; a graph generated from maze passages\n(s/def ::graph (s/every-kv ::maze-spec/coordinate (s/coll-of ::maze-spec/coordinate)))\n\n;; an item within a priority map\n(s/def ::distance int?)\n(s/def ::via ::maze-spec/coordinate)\n(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))\n\n;; a priority map\n(s/def ::priority-map (s/every-kv ::maze-spec/coordinate ::priority-map-item))\n\n;; coordinate-seq\n(s/def ::coord-seq (s/and seq? (s/coll-of ::maze-spec/coordinate)))&quot;, :offset 681, :ns &quot;user&quot;} {:command &quot;(s/valid? ::priority-map {[0 0] {:distance 0 :via [0 1]}})&quot;, :offset 58, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [solver.spec :as solver-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]\n            [clojure.spec.alpha :as s]))&quot;, :offset 255, :ns &quot;user&quot;} {:command &quot;(s/valid? ::priority-map (priority-map-keyfn #(:distance %)  [0 0] {:distance 0 :via [0 1]}))&quot;, :offset 93, :ns &quot;solver.core&quot;} {:command &quot;(s/valid? ::solver-spec/priority-map (priority-map-keyfn #(:distance %) [0 0] {:distance 0 :via [0 1]}))&quot;, :offset 104, :ns &quot;solver.core&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [solver.spec :as solver-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]\n            [clojure.spec.alpha :as s]))\n\n(def maze {:maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  {:pre  [(s/valid? ::maze-spec/passages passages)]\n   :post [(s/valid? ::solver-spec/graph %)]}\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   {:post [(s/valid? ::solver-spec/priority-map %)]}\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post [(s/valid? ::solver-spec/priority-map %)]}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages :as maze}]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(s/valid? ::solver-spec/priority-map %)]}\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  {:pre  [(s/valid? ::solver-spec/priority-map priority-map)\n          (s/valid? ::maze-spec/coordinate goal)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via)))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  {:pre  [(s/valid? ::maze-spec/maze maze)\n          (s/valid? ::solver-spec/algorithm algorithm)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path (get-in maze [:maze-config :goal]))))&quot;, :offset 4973, :ns &quot;user&quot;} {:command &quot;(def maze {:_id \&quot;1\&quot;\n           :maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at #inst\&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 730, :ns &quot;solver.core&quot;} {:command &quot;(solve-maze maze \&quot;dijkstra\&quot;)&quot;, :offset 28, :ns &quot;solver.core&quot;} {:command &quot;(s/explain? ::maze-spec/maze maze)&quot;, :offset 34, :ns &quot;solver.core&quot;} {:command &quot;(def maze {:_id \&quot;1\&quot;\n           :maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at \&quot;2020-03-29T19:55:41.569-00:00\&quot;})&quot;, :offset 725, :ns &quot;solver.core&quot;} {:command &quot;(s/explain ::maze-spec/maze maze)&quot;, :offset 33, :ns &quot;solver.core&quot;}], :remote [{:command &quot;(ns solver.core\n                                                                 (:require [maze.spec :as maze-spec]\n                                                                           [solver.spec :as solver-spec]\n                                                                           [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n                                                                           [clojure.set :refer :all]\n                                                                           [clojure.spec.alpha :as s]))\n\n(def maze {:_id \&quot;1\&quot;\n           :maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at \&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  {:pre  [(s/valid? ::maze-spec/passages passages)]\n   :post [(s/valid? ::solver-spec/graph %)]}\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post [(s/valid? ::solver-spec/priority-map %)]}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages :as maze}]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(s/valid? ::solver-spec/priority-map %)]}\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  {:pre  [(s/valid? ::solver-spec/priority-map priority-map)\n          (s/valid? ::maze-spec/coordinate goal)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via)))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  {:pre  [(s/valid? ::maze-spec/maze maze)\n          (s/valid? ::solver-spec/algorithm algorithm)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path (get-in maze [:maze-config :goal]))))&quot;, :offset 5250, :ns &quot;user&quot;} {:command &quot;(gen-priority-map)&quot;, :offset 18, :ns &quot;solver.core&quot;} {:command &quot;(gen-priority-map (passages-&gt;graph (:passages maze)))&quot;, :offset 53, :ns &quot;solver.core&quot;} {:command &quot;(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post []}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))&quot;, :offset 309, :ns &quot;solver.core&quot;} {:command &quot;(int? ##Inf)&quot;, :offset 12, :ns &quot;user&quot;} {:command &quot;(s/def ::distance (or int? (= ##Inf %)))&quot;, :offset 40, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or int? #(= ##Inf %)))&quot;, :offset 41, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [solver.spec :as solver-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]\n            [clojure.spec.alpha :as s]))&quot;, :offset 255, :ns &quot;user&quot;} {:command &quot;(s/def ::distance (s/or int? #(= ##Inf %)))&quot;, :offset 43, :ns &quot;solver.spec&quot;} {:command &quot;(= ##Inf ##Inf)&quot;, :offset 15, :ns &quot;user&quot;} {:command &quot;(s/def ::distance (or int? (fn [x] (prn x) true)))&quot;, :offset 50, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or int? Integer/MAX_VALUE))&quot;, :offset 46, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/int-in 0 ##Inf))&quot;, :offset 37, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or int? #(= \&quot;a\&quot; %)))&quot;, :offset 39, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or #(= \&quot;a\&quot; %) int?))&quot;, :offset 39, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or #(= ##Inf %) int?))&quot;, :offset 41, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance \&quot;a\&quot;)&quot;, :offset 25, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.spec\n  (:require [maze.spec :as maze-spec]\n            [clojure.spec.alpha :as s]))\n\n;; allowed algorithms for solving\n(s/def ::algorithm #{\&quot;dijkstra\&quot;})\n\n;; a graph generated from maze passages\n(s/def ::graph (s/every-kv ::maze-spec/coordinate (s/coll-of ::maze-spec/coordinate)))\n\n;; an item within a priority map\n(s/def ::distance (or #(= ##Inf %) int?))\n(s/def ::via ::maze-spec/coordinate)\n(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))\n\n;; a priority map\n(s/def ::priority-map (s/every-kv ::maze-spec/coordinate ::priority-map-item))\n\n;; coordinate-seq\n(s/def ::coord-seq (s/and seq? (s/coll-of ::maze-spec/coordinate)))&quot;, :offset 699, :ns &quot;user&quot;} {:command &quot;1&quot;, :offset 1, :ns &quot;user&quot;} {:command &quot;(prn \&quot;1\&quot;)&quot;, :offset 9, :ns &quot;user&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [solver.spec :as solver-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]\n            [clojure.spec.alpha :as s]))\n\n(def maze {:_id \&quot;1\&quot;\n           :maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at \&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  {:pre  [(s/valid? ::maze-spec/passages passages)]\n   :post [(s/valid? ::solver-spec/graph %)]}\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post []}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages :as maze}]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(s/valid? ::solver-spec/priority-map %)]}\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  {:pre  [(s/valid? ::solver-spec/priority-map priority-map)\n          (s/valid? ::maze-spec/coordinate goal)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via)))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  {:pre  [(s/valid? ::maze-spec/maze maze)\n          (s/valid? ::solver-spec/algorithm algorithm)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path (get-in maze [:maze-config :goal]))))&quot;, :offset 4896, :ns &quot;user&quot;} {:command &quot;(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post [(s/valid? ::solver-spec/priority-map %)]}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))&quot;, :offset 348, :ns &quot;solver.core&quot;} {:command &quot;(s/explain ::solver-spec/priority-map (gen-priority-map (passages-&gt;graph (:passages maze))))&quot;, :offset 92, :ns &quot;solver.core&quot;} {:command &quot;(s/explain ::solver-spec/priority-map maze)&quot;, :offset 43, :ns &quot;solver.core&quot;} {:command &quot;(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages :as maze}]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post []}\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))&quot;, :offset 2299, :ns &quot;solver.core&quot;} {:command &quot;(ns solver.spec\n  (:require [maze.spec :as maze-spec]\n            [clojure.spec.alpha :as s]))\n\n;; allowed algorithms for solving\n(s/def ::algorithm #{\&quot;dijkstra\&quot;})\n\n;; a graph generated from maze passages\n(s/def ::graph (s/every-kv ::maze-spec/coordinate (s/coll-of ::maze-spec/coordinate)))\n\n;; an item within a priority map\n(s/def ::distance (or #(= ##Inf %) int?))\n(s/def ::via ::maze-spec/nilable-coordinate)\n(s/def ::priority-map-item (s/keys :req-un [::distance ::via]\n                                   :opt-un []))\n\n;; a priority map\n(s/def ::priority-map (s/every-kv ::maze-spec/coordinate ::priority-map-item))\n\n;; coordinate-seq\n(s/def ::coord-seq (s/and seq? (s/coll-of ::maze-spec/coordinate)))&quot;, :offset 707, :ns &quot;user&quot;} {:command &quot;(s/valid? 1)&quot;, :offset 12, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (or #(= ##Inf %) (s/int-in 0 Integer/MAX_VALUE)))&quot;, :offset 67, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/or #(= ##Inf %) (s/int-in 0 Integer/MAX_VALUE)))&quot;, :offset 69, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::pos-int (s/int-in 0 Integer/MAX_VALUE))&quot;, :offset 48, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::pos-int)&quot;, :offset 20, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::pos-int 0)&quot;, :offset 22, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::pos-int ##Inf)&quot;, :offset 26, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::pos-int 100)&quot;, :offset 24, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::inf ##Inf)&quot;, :offset 19, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::inf (= % ##Inf))&quot;, :offset 25, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::inf #(= % ##Inf))&quot;, :offset 26, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::inf ##Inf)&quot;, :offset 22, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/or ::pos-int ::inf))&quot;, :offset 41, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance 1)&quot;, :offset 23, :ns &quot;solver.spec&quot;} {:command &quot;(s/def ::distance (s/or :pos-int ::pos-int :infinite? ::inf))&quot;, :offset 61, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance ##Inf)&quot;, :offset 27, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance 2)&quot;, :offset 23, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance -1)&quot;, :offset 24, :ns &quot;solver.spec&quot;} {:command &quot;(s/valid? ::distance 0)&quot;, :offset 23, :ns &quot;solver.spec&quot;} {:command &quot;(ns solver.core\n  (:require [maze.spec :as maze-spec]\n            [solver.spec :as solver-spec]\n            [clojure.data.priority-map :refer [priority-map priority-map-keyfn]]\n            [clojure.set :refer :all]\n            [clojure.spec.alpha :as s]))\n\n(def maze {:_id \&quot;1\&quot;\n           :maze-config {:size {:rows 4, :cols 4}, :start [0 0], :goal [3 3], :algorithm \&quot;binary-tree\&quot;},\n           :passages [[[0 0] [0 1]]\n                      [[0 1] [0 2]]\n                      [[0 2] [0 3]]\n                      [[1 0] [1 1]]\n                      [[1 1] [0 1]]\n                      [[1 2] [0 2]]\n                      [[1 3] [0 3]]\n                      [[2 0] [1 0]]\n                      [[2 1] [2 2]]\n                      [[2 2] [2 3]]\n                      [[2 3] [1 3]]\n                      [[3 0] [3 1]]\n                      [[3 1] [3 2]]\n                      [[3 2] [2 2]]\n                      [[3 3] [2 3]]],\n           :generated-at \&quot;2020-03-29T19:55:41.569-00:00\&quot;})\n\n(defn passages-&gt;graph\n  \&quot;Creates a graph based off the given passages vector\&quot;\n  [passages]\n  {:pre  [(s/valid? ::maze-spec/passages passages)]\n   :post [(s/valid? ::solver-spec/graph %)]}\n  (reduce\n    (fn [graph [a b]]\n      (merge-with union graph {a #{b} b #{a}}))\n    {} passages))\n\n(defn gen-priority-map\n  \&quot;Generates a priority map from the given graph\&quot;\n  ([]\n   (priority-map-keyfn #(:distance %)))\n  ([graph]\n   {:pre  [(s/valid? ::solver-spec/graph graph)]\n    :post [(s/valid? ::solver-spec/priority-map %)]}\n   (merge\n     (priority-map-keyfn #(:distance %))\n     (zipmap (keys graph) (repeat {:distance ##Inf :via nil})))))\n\n(defn solve-dijkstra\n  \&quot;Solves a maze using Dijkstra's algorithm\&quot;\n  [{{start :start goal :goal} :maze-config passages :passages :as maze}]\n  {:pre  [(s/valid? ::maze-spec/maze maze)]\n   :post [(s/valid? ::solver-spec/priority-map %)]}\n  ;; make a graph out of the given passages for shortest route computation\n  (let [graph (passages-&gt;graph passages)]\n    ;; solve usuing recursion, using two priority queues\n    (loop [queue (assoc-in (gen-priority-map graph) [start :distance] 0)\n           doneq (gen-priority-map)]\n      ;; adjust course if the priority queue is empty\n      (if (or  (empty? queue))\n        ;; return the completion priority queue once all nodes have been visited\n        doneq\n        ;; compute the next pass if not\n        (let\n          ;; coord is the current visited item being looked at within the queue\n          ;; neighbours is the unvisited sibling items of coord within the graph\n          [[coord {dist :distance via :via}] (first queue)\n           neighbours (filter\n                        (fn [neighbour]\n                          (not (contains? (into (hash-set) (keys doneq)) neighbour)))\n                        (get graph coord))]\n          ;; adjust course\n          (cond\n            ;; return the final iteration of the done queue\n            (= coord goal) (conj doneq (first queue))\n            ;; recur without computing new distances\n            (empty? neighbours) (recur (pop queue) (conj doneq (first queue)))\n            ;; recur and calculate new distances of unvisited neighbours\n            :else (let [queue-items (into {} (map\n                                               (fn [neighbour]\n                                                 (let [{this-distance :distance via-coord :via :as queue-item} (get queue neighbour)]\n                                                   ;; each neighbour has an implicit weight of 1 within the graph\n                                                   (if (&lt; (inc dist) this-distance)\n                                                     {neighbour {:distance (inc dist) :via coord}}\n                                                     queue-item)))\n                                               neighbours))\n                        queue' (merge queue queue-items)]\n                    (recur (pop queue') (conj doneq (first queue'))))))))))\n\n;(s/explain ::solver-spec/priority-map (solve-dijkstra maze))\n\n(defn priority-map-&gt;path\n  \&quot;Returns an ordered collection of coordinates that represents a path through a maze\&quot;\n  [priority-map goal]\n  {:pre  [(s/valid? ::solver-spec/priority-map priority-map)\n          (s/valid? ::maze-spec/coordinate goal)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (loop [map priority-map\n         path [goal]\n         current (get map (last path))]\n    (if (empty? map)\n      (reverse path)\n      (let [coord (last path)\n            {via :via} current]\n        (if (= nil via)\n          (reverse path)\n          (recur (dissoc map coord) (conj path via) (get map via)))))))\n\n(defn solve-maze\n  \&quot;Solves the given maze using the given algorithm\&quot;\n  [maze algorithm]\n  {:pre  [(s/valid? ::maze-spec/maze maze)\n          (s/valid? ::solver-spec/algorithm algorithm)]\n   :post [(s/valid? ::solver-spec/coord-seq %)]}\n  (-&gt;\n    (cond\n      (= algorithm \&quot;dijkstra\&quot;) (solve-dijkstra maze))\n    (priority-map-&gt;path (get-in maze [:maze-config :goal]))))&quot;, :offset 4998, :ns &quot;user&quot;} {:command &quot;(s/explain ::solver-spec/priority-map (solve-dijkstra maze))&quot;, :offset 60, :ns &quot;solver.core&quot;}]}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.Server REPL">
    <configuration name="REPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="client" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration name="Server REPL" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <module name="client" />
      <setting name="host" value="127.0.0.1" />
      <setting name="port" value="7000" />
      <setting name="replType" value="0" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.REPL" />
      <item itemvalue="Clojure REPL.Server REPL" />
    </list>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="d8b76d46-8a30-41b4-b195-b0d8be12781b" name="Default Changelist" comment="" />
      <created>1585587849786</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1585587849786</updated>
    </task>
    <servers />
  </component>
  <component name="UnknownFeatures">
    <option featureType="com.intellij.fileTypeFactory" implementationName="*.js" />
  </component>
</project>